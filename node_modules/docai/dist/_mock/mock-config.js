export const COMMENTED_DIR_PATH = '/Users/fabien/Projects/Libération/autodoc/_mock/run/commented';
const GENERATED_DIR_MD_PATH = '/Users/fabien/Projects/Libération/autodoc/_mock/run/generated';
export const cache = {
    [`${COMMENTED_DIR_PATH}/src/back/createUser.js`]: `${GENERATED_DIR_MD_PATH}/src/back/createUser.md`,
    [`${COMMENTED_DIR_PATH}/src/back/deleteUser.js`]: `${GENERATED_DIR_MD_PATH}/src/back/deleteUser.md`,
    [`${COMMENTED_DIR_PATH}/src/back/getUsers.js`]: `${GENERATED_DIR_MD_PATH}/src/back/getUsers.md`,
    [`${COMMENTED_DIR_PATH}/src/front/c.js`]: `${GENERATED_DIR_MD_PATH}/src/front/c.md`,
    [`${COMMENTED_DIR_PATH}/src/front/outer/b.js`]: `${GENERATED_DIR_MD_PATH}/src/front/outer/b.md`,
    [`${COMMENTED_DIR_PATH}/src/front/under/a.js`]: `${GENERATED_DIR_MD_PATH}/src/front/under/a.md`
};
export const descriptions = {
    [`${COMMENTED_DIR_PATH}/src/front/under/a.js`]: 'Ce code contient trois fonctions qui effectuent des opérations sur des matrices.\n' +
        '\n' +
        "La première fonction, `matrixAddition`, prend deux matrices `matrixA` et `matrixB` en entrée et renvoie une nouvelle matrice qui est le résultat de l'addition des deux matrices. La fonction utilise une boucle `for` pour parcourir les éléments des matrices et les ajouter ensemble. La matrice résultante est stockée dans la variable `result` et est renvoyée à la fin de la fonction.\n" +
        '\n' +
        'La deuxième fonction, `matrixMultiplication`, prend également deux matrices `matrixA` et `matrixB` en entrée et renvoie une nouvelle matrice qui est le résultat de la multiplication des deux matrices. La fonction utilise trois boucles `for` pour parcourir les éléments des matrices et effectuer les calculs nécessaires pour la multiplication matricielle. La matrice résultante est stockée dans la variable `result` et est renvoyée à la fin de la fonction.\n' +
        '\n' +
        "La troisième fonction, `matrixTranspose`, prend une matrice `matrix` en entrée et renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée. La fonction utilise deux boucles `for` pour parcourir les éléments de la matrice d'entrée et les placer dans la position correspondante de la matrice transposée. La matrice transposée est stockée dans la variable `result` et est renvoyée à la fin de la fonction.\n" +
        '\n' +
        "Enfin, le module exporte les trois fonctions `matrixAddition`, `matrixMultiplication` et `matrixTranspose` pour qu'elles puissent être utilisées dans d'autres parties du code.",
    [`${COMMENTED_DIR_PATH}/src/front/outer/b.js`]: 'Ce code est un module JavaScript qui exporte trois fonctions: dotProduct, crossProduct et vectorMagnitude.\n' +
        '\n' +
        "La fonction dotProduct prend deux vecteurs en entrée (vector1 et vector2) et vérifie d'abord si les deux vecteurs ont la même longueur. Si ce n'est pas le cas, une erreur est levée. Sinon, la fonction utilise la méthode reduce pour calculer le produit scalaire des deux vecteurs. Le produit scalaire est calculé en multipliant chaque élément correspondant des deux vecteurs et en les ajoutant tous ensemble. Le résultat est renvoyé.\n" +
        '\n' +
        "La fonction crossProduct prend également deux vecteurs en entrée (vector1 et vector2) et vérifie si les deux vecteurs ont une longueur de 3. Si ce n'est pas le cas, une erreur est levée. Sinon, la fonction calcule le produit vectoriel des deux vecteurs en utilisant la formule du produit vectoriel pour les vecteurs en trois dimensions. Le résultat est renvoyé sous forme d'un nouveau vecteur.\n" +
        '\n' +
        'La fonction vectorMagnitude prend un vecteur en entrée et calcule la magnitude (ou la norme) du vecteur en utilisant la formule de la racine carrée de la somme des carrés de chaque élément du vecteur. Le résultat est renvoyé.\n' +
        '\n' +
        "Le module exporte ensuite les trois fonctions afin qu'elles puissent être utilisées dans d'autres fichiers JavaScript.",
    [`${COMMENTED_DIR_PATH}/src/front/c.js`]: 'Ce code définit une fonction appelée "computeComplexOperation" qui effectue une opération complexe sur des matrices et des vecteurs. \n' +
        '\n' +
        'Le code commence par importer deux fonctions, "matrixMultiplication" et "matrixAddition", à partir du fichier "./under/a". Ces fonctions sont utilisées pour effectuer la multiplication et l\'addition de matrices respectivement. \n' +
        '\n' +
        'Ensuite, le code importe trois fonctions, "dotProduct", "crossProduct" et "vectorMagnitude", à partir du fichier "./outer/b". Ces fonctions sont utilisées pour effectuer le produit scalaire, le produit vectoriel et le calcul de la magnitude d\'un vecteur respectivement. \n' +
        '\n' +
        'La fonction "computeComplexOperation" prend quatre arguments : "matrixA", "matrixB", "vector1" et "vector2". \n' +
        '\n' +
        "À l'intérieur de la fonction, le code effectue les opérations suivantes : \n" +
        '\n' +
        '1. Il multiplie les matrices "matrixA" et "matrixB" en utilisant la fonction "matrixMultiplication" et stocke le résultat dans la variable "matrixProduct". \n' +
        '2. Il additionne les matrices "matrixA" et "matrixB" en utilisant la fonction "matrixAddition" et stocke le résultat dans la variable "matrixSum". \n' +
        '3. Il calcule le produit scalaire des vecteurs "vector1" et "vector2" en utilisant la fonction "dotProduct" et stocke le résultat dans la variable "dotProd". \n' +
        '4. Il calcule le produit vectoriel des vecteurs "vector1" et "vector2" en utilisant la fonction "crossProduct" et stocke le résultat dans la variable "crossProd". \n' +
        '5. Il calcule la magnitude du vecteur "crossProd" en utilisant la fonction "vectorMagnitude" et stocke le résultat dans la variable "crossProdMagnitude". \n' +
        '6. Il multiplie chaque valeur de la matrice "matrixSum" par le produit scalaire "dotProd" en utilisant la méthode "map" et stocke le résultat dans la variable "weightedMatrixSum". \n' +
        '7. Il multiplie la matrice "weightedMatrixSum" par la matrice "matrixProduct" en utilisant la fonction "matrixMultiplication" et stocke le résultat dans la variable "resultMatrix". \n' +
        '8. Il multiplie chaque valeur de la matrice "resultMatrix" par la magnitude du vecteur "crossProd" en utilisant la méthode "map" et stocke le résultat dans la variable "finalMatrix". \n' +
        '9. Il retourne la matrice "finalMatrix" en tant que résultat de la fonction "computeComplexOperation". \n' +
        '\n' +
        'Enfin, le code exporte la fonction "computeComplexOperation" pour qu\'elle puisse être utilisée dans d\'autres fichiers.',
    [`${COMMENTED_DIR_PATH}/src/back/getUsers.js`]: 'Ce code est un module exportant une fonction asynchrone appelée "getUsers". Cette fonction est utilisée pour gérer une requête HTTP et renvoyer une réponse JSON contenant des utilisateurs.\n' +
        '\n' +
        'Le code commence par importer une fonction appelée "computeComplexOperation" à partir d\'un fichier "../src/c". Cette fonction n\'est pas définie dans le code donné, mais elle est utilisée plus tard.\n' +
        '\n' +
        'Ensuite, la fonction "getUsers" initialise deux matrices (matrixA et matrixB) et deux vecteurs (vector1 et vector2) avec des valeurs spécifiques.\n' +
        '\n' +
        'Ensuite, la fonction appelle la fonction "computeComplexOperation" avec les matrices et les vecteurs comme arguments. Le résultat de cette fonction est stocké dans une variable appelée "users".\n' +
        '\n' +
        'Enfin, la fonction renvoie une réponse HTTP avec un code de statut 200 et un corps JSON contenant un tableau d\'utilisateurs. Le tableau d\'utilisateurs est actuellement défini comme étant égal à la variable "users", mais cela pourrait être remplacé par de vraies données.',
    [`${COMMENTED_DIR_PATH}/src/back/createUser.js`]: 'createUser description',
    [`${COMMENTED_DIR_PATH}/src/back/deleteUser.js`]: 'deleteUser description'
};
// 1) On copie les fichiers vers un dossiers temporaire
// 2) On génère un objet description, avec comme
// clef un chemin du fichier dans le dossier temporaire (COMMENTED_DIR_PATH) et en valeur sa description généré par le model
// 3) On génère le markdown du code commented, situé dans COMMENTED_DIR_PATH, si on veut mocké cette partie
// on ajoute dans un objet cache, la clef le chemin du fichier commenté avec comme base COMMENTED_DIR_PATH, et comme valeur l'emplacement du markdown, avec comme base GENERATED_DIR_MD_PATH
// 4) Le markdown ensuite sera augmenté avec des liens pour des fonctions, le résultat sera dans OUTPUT
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1jb25maWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9fbW9jay9tb2NrLWNvbmZpZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FDN0IsK0RBQStELENBQUE7QUFDakUsTUFBTSxxQkFBcUIsR0FDekIsK0RBQStELENBQUE7QUFFakUsTUFBTSxDQUFDLE1BQU0sS0FBSyxHQUFHO0lBQ25CLENBQUMsR0FBRyxrQkFBa0IseUJBQXlCLENBQUMsRUFBRSxHQUFHLHFCQUFxQix5QkFBeUI7SUFDbkcsQ0FBQyxHQUFHLGtCQUFrQix5QkFBeUIsQ0FBQyxFQUFFLEdBQUcscUJBQXFCLHlCQUF5QjtJQUNuRyxDQUFDLEdBQUcsa0JBQWtCLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxxQkFBcUIsdUJBQXVCO0lBQy9GLENBQUMsR0FBRyxrQkFBa0IsaUJBQWlCLENBQUMsRUFBRSxHQUFHLHFCQUFxQixpQkFBaUI7SUFDbkYsQ0FBQyxHQUFHLGtCQUFrQix1QkFBdUIsQ0FBQyxFQUFFLEdBQUcscUJBQXFCLHVCQUF1QjtJQUMvRixDQUFDLEdBQUcsa0JBQWtCLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxxQkFBcUIsdUJBQXVCO0NBQ2hHLENBQUE7QUFFRCxNQUFNLENBQUMsTUFBTSxZQUFZLEdBQUc7SUFDMUIsQ0FBQyxHQUFHLGtCQUFrQix1QkFBdUIsQ0FBQyxFQUM1QyxvRkFBb0Y7UUFDcEYsSUFBSTtRQUNKLGlZQUFpWTtRQUNqWSxJQUFJO1FBQ0osMmNBQTJjO1FBQzNjLElBQUk7UUFDSix1YUFBdWE7UUFDdmEsSUFBSTtRQUNKLGlMQUFpTDtJQUNuTCxDQUFDLEdBQUcsa0JBQWtCLHVCQUF1QixDQUFDLEVBQzVDLDhHQUE4RztRQUM5RyxJQUFJO1FBQ0osb2JBQW9iO1FBQ3BiLElBQUk7UUFDSiw2WUFBNlk7UUFDN1ksSUFBSTtRQUNKLHFPQUFxTztRQUNyTyxJQUFJO1FBQ0osd0hBQXdIO0lBQzFILENBQUMsR0FBRyxrQkFBa0IsaUJBQWlCLENBQUMsRUFDdEMseUlBQXlJO1FBQ3pJLElBQUk7UUFDSix3T0FBd087UUFDeE8sSUFBSTtRQUNKLG1SQUFtUjtRQUNuUixJQUFJO1FBQ0osaUhBQWlIO1FBQ2pILElBQUk7UUFDSiw4RUFBOEU7UUFDOUUsSUFBSTtRQUNKLGdLQUFnSztRQUNoSyx1SkFBdUo7UUFDdkosa0tBQWtLO1FBQ2xLLHVLQUF1SztRQUN2Syw4SkFBOEo7UUFDOUosd0xBQXdMO1FBQ3hMLHlMQUF5TDtRQUN6TCwyTEFBMkw7UUFDM0wsMkdBQTJHO1FBQzNHLElBQUk7UUFDSiwwSEFBMEg7SUFDNUgsQ0FBQyxHQUFHLGtCQUFrQix1QkFBdUIsQ0FBQyxFQUM1QyxnTUFBZ007UUFDaE0sSUFBSTtRQUNKLDJNQUEyTTtRQUMzTSxJQUFJO1FBQ0oscUpBQXFKO1FBQ3JKLElBQUk7UUFDSixxTUFBcU07UUFDck0sSUFBSTtRQUNKLGtSQUFrUjtJQUNwUixDQUFDLEdBQUcsa0JBQWtCLHlCQUF5QixDQUFDLEVBQUUsd0JBQXdCO0lBQzFFLENBQUMsR0FBRyxrQkFBa0IseUJBQXlCLENBQUMsRUFBRSx3QkFBd0I7Q0FDM0UsQ0FBQTtBQUVELHVEQUF1RDtBQUN2RCxnREFBZ0Q7QUFDaEQsNEhBQTRIO0FBQzVILDJHQUEyRztBQUMzRyw0TEFBNEw7QUFDNUwsdUdBQXVHIn0=