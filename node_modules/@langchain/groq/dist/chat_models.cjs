"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatGroq = exports.messageToGroqRole = void 0;
const chat_models_1 = require("@langchain/core/language_models/chat_models");
const messages_1 = require("@langchain/core/messages");
const outputs_1 = require("@langchain/core/outputs");
const env_1 = require("@langchain/core/utils/env");
const groq_sdk_1 = __importDefault(require("groq-sdk"));
function messageToGroqRole(message) {
    const type = message._getType();
    switch (type) {
        case "system":
            return "system";
        case "ai":
            return "assistant";
        case "human":
            return "user";
        case "function":
            return "function";
        default:
            throw new Error(`Unknown message type: ${type}`);
    }
}
exports.messageToGroqRole = messageToGroqRole;
function convertMessagesToGroqParams(messages) {
    return messages.map((message) => {
        if (typeof message.content !== "string") {
            throw new Error("Non string message content not supported");
        }
        return {
            role: messageToGroqRole(message),
            content: message.content,
            name: message.name,
            function_call: message.additional_kwargs.function_call,
        };
    });
}
function groqResponseToChatMessage(message) {
    switch (message.role) {
        case "assistant":
            return new messages_1.AIMessage(message.content || "");
        default:
            return new messages_1.ChatMessage(message.content || "", message.role ?? "unknown");
    }
}
function _convertDeltaToMessageChunk(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
delta) {
    const { role } = delta;
    const content = delta.content ?? "";
    let additional_kwargs;
    if (delta.function_call) {
        additional_kwargs = {
            function_call: delta.function_call,
        };
    }
    else {
        additional_kwargs = {};
    }
    if (role === "user") {
        return new messages_1.HumanMessageChunk({ content });
    }
    else if (role === "assistant") {
        return new messages_1.AIMessageChunk({ content, additional_kwargs });
    }
    else if (role === "system") {
        return new messages_1.SystemMessageChunk({ content });
    }
    else {
        return new messages_1.ChatMessageChunk({ content, role });
    }
}
/**
 * Wrapper around Groq API for large language models fine-tuned for chat
 *
 * Groq API is compatible to the OpenAI API with some limitations. View the
 * full API ref at:
 * @link {https://docs.api.groq.com/md/openai.oas.html}
 *
 * To use, you should have the `GROQ_API_KEY` environment variable set.
 * @example
 * ```typescript
 * const model = new ChatGroq({
 *   temperature: 0.9,
 *   apiKey: process.env.GROQ_API_KEY,
 * });
 *
 * const response = await model.invoke([new HumanMessage("Hello there!")]);
 * console.log(response);
 * ```
 */
class ChatGroq extends chat_models_1.BaseChatModel {
    static lc_name() {
        return "ChatGroq";
    }
    _llmType() {
        return "groq";
    }
    get lc_secrets() {
        return {
            apiKey: "GROQ_API_KEY",
        };
    }
    constructor(fields) {
        super(fields ?? {});
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modelName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "llama2-70b-4096"
        });
        Object.defineProperty(this, "temperature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0.7
        });
        Object.defineProperty(this, "streaming", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "lc_serializable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        const apiKey = fields?.apiKey || (0, env_1.getEnvironmentVariable)("GROQ_API_KEY");
        if (!apiKey) {
            throw new Error(`Groq API key not found. Please set the GROQ_API_KEY environment variable or provide the key into "apiKey"`);
        }
        this.client = new groq_sdk_1.default({
            apiKey,
            dangerouslyAllowBrowser: true,
        });
        this.temperature = fields?.temperature ?? this.temperature;
        this.modelName = fields?.modelName ?? this.modelName;
        this.streaming = fields?.streaming ?? this.streaming;
    }
    async completionWithRetry(request, options) {
        return this.caller.call(async () => this.client.chat.completions.create(request, options));
    }
    invocationParams(options) {
        const params = super.invocationParams(options);
        return {
            ...params,
            model: this.modelName,
            temperature: this.temperature,
        };
    }
    async *_streamResponseChunks(messages, options, runManager) {
        const params = this.invocationParams(options);
        const messagesMapped = convertMessagesToGroqParams(messages);
        const response = await this.completionWithRetry({
            ...params,
            messages: messagesMapped,
            stream: true,
        }, params);
        for await (const data of response) {
            const choice = data?.choices[0];
            if (!choice) {
                continue;
            }
            const chunk = new outputs_1.ChatGenerationChunk({
                message: _convertDeltaToMessageChunk(choice.delta ?? {}),
                text: choice.delta.content ?? "",
                generationInfo: {
                    finishReason: choice.finish_reason,
                },
            });
            yield chunk;
            void runManager?.handleLLMNewToken(chunk.text ?? "");
        }
        if (options.signal?.aborted) {
            throw new Error("AbortError");
        }
    }
    async _generate(messages, options, runManager) {
        const tokenUsage = {};
        const params = this.invocationParams(options);
        const messagesMapped = convertMessagesToGroqParams(messages);
        if (this.streaming) {
            const stream = this._streamResponseChunks(messages, options, runManager);
            const finalChunks = {};
            for await (const chunk of stream) {
                const index = chunk.generationInfo?.completion ?? 0;
                if (finalChunks[index] === undefined) {
                    finalChunks[index] = chunk;
                }
                else {
                    finalChunks[index] = finalChunks[index].concat(chunk);
                }
            }
            const generations = Object.entries(finalChunks)
                .sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10))
                .map(([_, value]) => value);
            return { generations, llmOutput: { estimatedTokenUsage: tokenUsage } };
        }
        else {
            const data = await this.completionWithRetry({
                ...params,
                stream: false,
                messages: messagesMapped,
            }, {
                signal: options?.signal,
            });
            if ("usage" in data && data.usage) {
                const { completion_tokens: completionTokens, prompt_tokens: promptTokens, total_tokens: totalTokens, } = data.usage;
                if (completionTokens) {
                    tokenUsage.completionTokens =
                        (tokenUsage.completionTokens ?? 0) + completionTokens;
                }
                if (promptTokens) {
                    tokenUsage.promptTokens =
                        (tokenUsage.promptTokens ?? 0) + promptTokens;
                }
                if (totalTokens) {
                    tokenUsage.totalTokens = (tokenUsage.totalTokens ?? 0) + totalTokens;
                }
            }
            const generations = [];
            if ("choices" in data && data.choices) {
                for (const part of data.choices) {
                    const text = part.message?.content ?? "";
                    const generation = {
                        text,
                        message: groqResponseToChatMessage(part.message ?? { role: "assistant" }),
                    };
                    generation.generationInfo = {
                        ...(part.finish_reason
                            ? { finish_reason: part.finish_reason }
                            : {}),
                        ...(part.logprobs ? { logprobs: part.logprobs } : {}),
                    };
                    generations.push(generation);
                }
            }
            return {
                generations,
                llmOutput: { tokenUsage },
            };
        }
    }
}
exports.ChatGroq = ChatGroq;
